# Linux-note
学习linux与相关脚本

- [Linux-note](#linux-note)
  - [Linux命令](#linux命令)
    - [常用命令](#常用命令)
    - [部署systemd](#部署systemd)
  - [Shell命令](#shell命令)
    - [Shell变量](#shell变量)
      - [变量声明](#变量声明)
      - [变量使用](#变量使用)
      - [只读变量](#只读变量)
      - [删除变量](#删除变量)
      - [数据类型](#数据类型)
        - [字符串](#字符串)
        - [数字](#数字)
        - [数组](#数组)
    - [注释](#注释)
    - [字符串操作](#字符串操作)
      - [获取字符串长度](#获取字符串长度)
      - [提取子字符串/切割字符串](#提取子字符串切割字符串)
      - [查找字符](#查找字符)
    - [数组操作](#数组操作)
      - [获取数组中的所有元素](#获取数组中的所有元素)
      - [获取数组长度](#获取数组长度)
    - [传递参数](#传递参数)
    - [基本运算符](#基本运算符)
      - [算术运算符](#算术运算符)
      - [关系运算符](#关系运算符)
      - [布尔运算符](#布尔运算符)
      - [逻辑运算符](#逻辑运算符)
      - [字符串运算符](#字符串运算符)
      - [文件测试运算符](#文件测试运算符)
      - [自增/自减运算符](#自增自减运算符)
        - [使用let命令](#使用let命令)
        - [使用$(())](#使用)
        - [使用expr](#使用expr)
        - [使用(())](#使用-1)
    - [echo命令](#echo命令)
    - [printf命令](#printf命令)
      - [概念](#概念)
      - [常用字符速查](#常用字符速查)
    - [流程控制](#流程控制)
      - [if](#if)
      - [for循环](#for循环)
      - [while语句](#while语句)
      - [until循环](#until循环)
      - [case...esac](#caseesac)
    - [函数](#函数)
    - [输入输出重定向](#输入输出重定向)
      - [输出重定向](#输出重定向)
      - [输入重定向](#输入重定向)
      - [标准错误重定向](#标准错误重定向)
      - [管道](#管道)
      - [here Document](#here-document)

## Linux命令

### 常用命令

ls  
语法:`ls`
作用:列出当前目录中的目录与文件

pwd  
语法:`pwd`  
作用:显示当前的工作目录的路径

cd  
语法:`cd`  
作用:切换工作目录  
实例:  
`cd ..` 返回到上一级目录  
`cd /home` 前往home目录

mkdir  
语法:`mkdir [目录名]`  
作用:在当前目录下创建新目录

touch  
语法:`touch [文件名]`  
作用:创建空文件或者更新时间戳

rm  
语法:`rm [选项] [目录名/文件名]`   
作用:删除目录或者文件  
常用选项:  
`-r`递归删除目录中的目录与文件
`-f`强制删除目录中的目录与文件

cp  
语法:`cp [选项] [目标目录/文件] [目标地址]`  
作用:复制文件或者复制目录  
选项:  
`-r`递归复制

mv  
语法:`mv [源目标] [目标地址]`  
作用:移动文件/目录去目标地址

cat  
语法:`cat [文件]`  
作用:连接和显示文件内容

more/less  
语法:`more/less [文件]`  
作用:逐页显示文本文件内容

head/tail  
语法:`head/tail [选项] [文件]`  
作用:从开头查看文件/从结尾开始查看文件
选项:  
`-n` `head -n 10 filename`查看开头十行的内容
`-c` `tail -c 10 filename`查看结尾十个字节的内容

free  
语法:`free [选项]`  
作用:展示物理内存和交换内存的总量,使用量和空闲量  
选项:  
`-h`:是`--human`的缩写,就是会将结果转成更易读的单位

history  
语法:`history`  
作用:显示命令历史

netstat/ss  
语法:`netstat/ss [选项]`  
作用:显示各种网络相关信息,包括网络连接,路由表,接口统计信息
| 选项 | 英文全称  | 含义      | 作用                                               |
| ---- | --------- | --------- | -------------------------------------------------- |
| t    | tcp       | TCP协议   | 仅显示TCP协议相关的连接和监听端口                  |
| u    | udp       | UDP协议   | 仅显示UDP协议相关的连接和监听端口                  |
| l    | listening | 监听      | 仅显示处于监听状态的套接字                         |
| n    | numeric   | 数字形式  | 以数字形式显示地址和端口号                         |
| p    | program   | 程序/进程 | 显示正在使用该套接字的进程名和PID,通常需要root权限 |

lsof  
语法:`lsof [选项]`  
作用:自动化查找进程打开的文件及其关联的FD  
选项:  
`-p`:查询特定PID进程的信息,`lsof -p 1222`  
`-i`:查询特定端口的信息,`lsof -i :8080`

scp  
语法:`scp [本地文件路径] [目标服务器用户]@[ip]:[服务器路径]`  
作用:将本地文件上传到linux服务器上

journalctl  
语法:`journalctl [选项] [服务] [选项]`  
作用:查看服务的日志
常用:  
`journalctl -u [服务] -f`实时查看日志  
`journalctl --since "2025-12-11 10:00" --until "2025-12-11 12:00"`查看某个时间范围的日志  
`journalctl -u [服务] -xe`查看某个服务崩溃的日志

### 部署systemd

1. 创建systemd服务文件

    文件路径:/etc/systemd/system/[程序].service

    文件内容:
    ```
    [Unit]
    Description=[程序] Service #服务描述 
    After=network.target #程序在网络服务启动后再启动
    
    [Service]
    ExecStart=/home/apiBot/ApiBot #程序地址
    WorkingDirectory=/home/apiBot #工作目录
    Restart=always #是否自启动
    RestartSec=3 #自启动间隔
    StandardOutput=append:/home/apiBot/output.log #标准输出目录fd1
    StandardError=append:/home/apiBot/error.log #标准错误输出fd2
    
    [Install]
    WantedBy=multi-user.target #在命令行完全启动后启动
    ```

2. 启动服务
    - 重载服务文件:sudo systemctl daemon-reload
    - 设置开机自启动:sudo systemctl enable [服务名]
    - 启动服务:sudo systemctl start [服务名]
    - 查看运行状态:sudo systemctl status [服务名]
    - 停止服务:sudo systemctl stop [服务名]
    - 重启服务:sudo systemctl restart [服务名]
    - 禁用开机自启动:sudo systemctl disable [服务名]


## Shell命令

### Shell变量

#### 变量声明

命名和正常编程语言没有什么区别,不能使用数字开头,不能使用该语言的关键字

特别:不能使用$符号,无需关键字,声明的时候等号两边最好不要空格,会出现问题

```
EG.
普通变量:
Tag="B"
约定:常量使用全大写字母声明
PI="3.14"
```

#### 变量使用

使用美元符号放在前面表示使用

```
PI="3.14"
echo $PI
可以使用花括号帮助系统识别变量边界
echo ${PI}
```

#### 只读变量

先声明一个变量:PI="3.14"
设置成只读变量:readonly PI
只读变量无法修改


#### 删除变量

使用unset可以删除变量:unset PI  
**无法删除只读变量**


#### 数据类型

##### 字符串
shell中的默认类型,也是使用最多的类型

可以使用单引号或者双引号进行声明

单引号的字符都会原样输出,无法在单引号字符串中使用变量,单引号字符串中无法出现单个单引号,即便是转义也不行  

##### 数字

声明:`declare -i`

##### 数组

声明1:`TEST_ARRAY=(value1 value2 value3)`

声明2:单个声明
TEST[0]=value1
TEST[1]=value2

声明关联数组(感觉是个map,key->value)  
`declare -A site=(["google"]="www.google.com" ["runoob"]="www.runoob.com" ["taobao"]="www.taobao.com")`  
这个关联数组也可以像上面一样,先声明之后再给每一个元素单独赋值


访问方式:`${TEST_ARRAY[0]}`

### 注释

`#`号之后的内容不会被执行
```
#这里就会被忽略
```

### 字符串操作

#### 获取字符串长度

```
my_string="abcde"
echo ${#string}  #输出5
```

#### 提取子字符串/切割字符串

```
#定义一个字符串
my_string="hello"
#获取第二到第四个字符
echo ${my_string:1:4}
```


#### 查找字符

```
my_string="hello_world"
echo `expr index ${my_string} ow`
#查找字符o或者w的位置,谁先找到就返回谁的下标
```

### 数组操作

#### 获取数组中的所有元素

使用`@`或者`*`可以获取数组中的所有元素
```
my_arr=("A" "B" "C")
echo ${my_arr[@]}

#输出3
```

在数组前加上一个`!`可以获取所有的index/key
```
my_arr=("A" "B" "C")
echo ${!my_arr[@]}

#输出0 1 2,如果是关联数组,则输出对应的key
```

#### 获取数组长度
```
my_arr=("A" "B" "C")
echo ${#my_arr[@]} #如果不加上@就等价于获取第一个元素的长度
```

### 传递参数

脚本内获取参数的格式为`$n`,n代表一个数字,1表示执行的第一个参数,2表示执行脚本的第二个参数

特殊参数
| 参数处理 | 说明                           |
| -------- | ------------------------------ |
| $0       | 执行的文件名(包含文件路径)     |
| $#       | 传递到脚本的参数个数           |
| $*       | 将输入的参数以一个字符串输出   |
| $$       | 脚本运行的进程的进程号         |
| $!       | 后台运行的最后一个进程的进程号 |
| $@       | 直接输出所有的参数             |
| $-       | 显示shell使用的当前选项        |
| $?       | 显示最后命令的退出状态         |

### 基本运算符

#### 算术运算符

原生bash不支持简单的数学运算,必须通过其他的命令来实现

最常用的是expr命令,可以计算一个表达式的值,表达式必须使用 **`**来包裹

例如:
```
val=`expr 2 + 2`
echo "两数之和为:${val}"
```

**表达式与运算符之间需要空格,就像是css中的calc计算函数一样**

运算符号和一般的编程语言没什么区别:
`+ - * / % =(赋值) == !=`  
**\*号之前需要加上\\来转义不然无法使用,`expr $a \* $b`**

如果作为流程判断语句中的表达式使用时,放入[]中时两边也需要空格,例如`[$a + $b]`是错误的  
必须写成`[ $a + $b ]`

#### 关系运算符

关系运算符是只支持数字,并不支持字符串,除非字符串的值是数字

| 运算符 | 说明           |
| ------ | -------------- |
| -eq    | 判断是否相等   |
| -ne    | 判断是否不相等 |
| -gt    | >              |
| -lt    | <              |
| -ge    | >=             |
| -le    | <=             |

```
e/eq:equal
n:not
g:greater
l:less
t:than
```

#### 布尔运算符

| 运算符 | 说明        |
| ------ | ----------- |
| !      | 非运算,取反 |
| -o     | \|\|        |
| -a     | &&          |


#### 逻辑运算符

| 运算符 | 说明    |
| ------ | ------- |
| &&     | 逻辑AND |
| \|\|   | 逻辑OR  |

**布尔运算符和逻辑运算符的区别**
```
简单来说:
布尔运算符用来连接条件测试
逻辑运算符用来连接命令

判断依据:
布尔运算符:条件表达式的真假结果
逻辑运算符:基于命令的退出状态码,只有执行正确的命令才返回0,shell中0用来表示true
```

**最佳实践**
```
现代基本都是用[[]]结构进行条件判断,这样可以使用&&来连接条件判断,防止-a命令带来的干扰

在[[]]中使用==来进行字符串判等,使用-eq来进行数值判等

$(())或者(())使用==来进行数值判等

$(())会返回一个字符串,作为值存在,(())只是单纯执行了这个命令
```

#### 字符串运算符

| 运算符 | 说明                    |
| ------ | ----------------------- |
| =      | 判断相等                |
| !=     | 判断不相等              |
| -z     | 判断字符串的长度是否为0 |
| -n     | 判断字符串长度是否不为0 |

**这些符号都使用在表达式前  eg: -n$a**

#### 文件测试运算符

太多了,挑了几个感觉会常用的
| 运算符   | 说明                                            |
| -------- | ----------------------------------------------- |
| -w/-x/-r | 判断是否可写/可执行/可读                        |
| -s       | 判断文件是否为空,不为空返回true                 |
| -e       | 判断目录/文件是否存在                           |
| -d       | 判断文件是否是目录                              |
| -f       | 判断文件是否是普通文件,既不是目录也不是设备文件 |

#### 自增/自减运算符

##### 使用let命令
```
num=1

let num++

let num--
```

##### 使用$(())
```
num=1

num=$((num + 1))

num=$((num - 1))
```

##### 使用expr
```
num=1

num=$(expr $num + 1)

num=$(expr $num - 1)
```

##### 使用(())
```
num=1

((num++))

((num--))
```

**最佳实践:(()),目前最常用的,性能最好,语法简洁**


### echo命令

| 关键点     | 说明                                    |
| ---------- | --------------------------------------- |
| 基本语法   | echo [选项] [字符串]                    |
| 常用选项   | -n输出不换行 -e启动解析字符串中的转义符 |
| 变量输出   | 使用$变量名,最好使用双引号              |
| 彩色输出   | 使用ANSI转移码\033[XXm                  |
| 输出重定向 | >覆盖文件,>>追加到文件的末尾            |
| 多行输出   | 使用\n换行                              |
| 可移植建议 | 复杂的echo建议直接使用printf            |

### printf命令

#### 概念

| 概念       | 说明                 | 示例                  |
| ---------- | -------------------- | --------------------- |
| 基础语法   | printf "format" args | printf "这是%s" "pen" |
| 格式说明符 | 以%开头,和c基本一致  | %d/%f                 |
| 转义字符   | 特殊字符表示         | \n,\t                 |
| 字段宽度   | 控制输出最小宽度     | %10s(十个字符宽)      |
| 精度控制   | 浮点数小数位数       | %.2f(两位小数)        |

#### 常用字符速查
| 说明符 | 用途         |
| ------ | ------------ |
| %s     | 字符串       |
| %d     | 十进制整数   |
| %x     | 十六进制整数 |
| %f     | 浮点数       |
| %.2f   | 2位小数      |
| %c     | 单个字符     |
| %%     | 百分号       |

### 流程控制

#### if

**else块中没有语句就不能书写**

**if 块**
```
if condition;
then 
  command1
  command2
fi
```

**if else块**
```
if condition;
then
  command1
  ...
else
  command
  ...
fi
```

**if elseif else块**
```
if condition;
then
  command1
  ...
elif condition2;
then
  command
  ...
else
  command
  ...
fi
```

#### for循环

```
for item in item1 item2 item3...
do
  command
  ...
done
```

#### while语句
```
while condition
do
  command
  ...
done
```

死循环:
```
while :
do
  command
  ...
done

while true
do
  command
done

for((;;))
```

#### until循环
```
until condition
do
  command
done
```

#### case...esac

类似switch...case

```
case 值 in
mode1)
  command
  ...
  ;;
mode2)
  command
  ...
  ;;
  *) #相当于default
  command
  ;;
esac
```

**跳出循环也是传统的break跳出循环,continue跳出当前循环**

### 函数

```
[ function ] funcName ()
{
  action
  [return int;]
}

[]中为可选

demoFun(){
  echo "这是我的第一个shell函数"

  echo "这是我的第一个参数$1"
}

echo "---函数开始执行---"
demoFun "helloworld"
echo "---函数执行完毕---"
```

使用$?去获取函数返回值
**$?仅对上一条指令负责,所以获得返回值之后,有需要必须马上使用参数保存**
想要为函数传递参数,就和为脚本传递参数一样,$1,$2之类的

### 输入输出重定向

在Linux/Unix系统中,每个程序(命令)在执行时通常会处理三个默认的I/O流(文件描述符):

| 流名称           | 描述符(FD) | 默认位置                 |
| ---------------- | ---------- | ------------------------ |
| 标准输入(stdin)  | 0          | 键盘(或前一个命令的输出) |
| 标准输出(stdout) | 1          | 终端屏幕                 |
| 标准错误(stderr) | 2          | 终端屏幕                 |

#### 输出重定向

1.覆盖写入(>)
语法:`command > file`
作用:将`command`的标准输出写入`file`.如果内容存在,则会被**覆盖**

2.追加写入(>>)
语法:`command >> file`
作用:将`command`的标准输出追加到`file`的末尾.如果`file`不存在,则会创建它

#### 输入重定向

语法:`command < file`
作用:将`file`的内容作为`command`的标准输入

#### 标准错误重定向

语法:`command 2> file`
作用:将`command`的标准错误重定向到`file`,并覆盖原有内容


**同时重定向错误输出和标准输出到同一个文件**
```
command > file 2>&1

command >> file 2> &1 追加
```

丢弃标准错误

存在一个特殊设备文件`/dev/null`,他会丢弃所有写入它的数据

#### 管道

语法:`command1|command2`
作用:`command1`的标准输出作为`command2`的标准输入

#### here Document

语法:
```
command << DELIMITER
...input line...
DELIMITER(自定义字符,首尾一致即可)
```

作用:支持多行文本作为标准输入


特殊配置
| 特性       | 操作符        | 作用                                |
| ---------- | ------------- | ----------------------------------- |
| 标准       | <<DELIMITER   | 接受多行输入,会展开变量和命令替换   |
| 字面值     | <<'DELIMITER' | 接受多行输入,不会展开变量和命令替换 |
| 抑制制表符 | <<- DELIMITER | 忽略内容行首的Tab字符,方便脚本缩进  |