# Linux-note
学习linux与相关脚本

- [Linux-note](#linux-note)
  - [Linux命令](#linux命令)
  - [Shell命令](#shell命令)
    - [Shell变量](#shell变量)
      - [变量声明](#变量声明)
      - [变量使用](#变量使用)
      - [只读变量](#只读变量)
      - [删除变量](#删除变量)
      - [数据类型](#数据类型)
        - [字符串](#字符串)
        - [数字](#数字)
        - [数组](#数组)
    - [注释](#注释)
    - [字符串操作](#字符串操作)
      - [获取字符串长度](#获取字符串长度)
      - [提取子字符串/切割字符串](#提取子字符串切割字符串)
      - [查找字符](#查找字符)
    - [数组操作](#数组操作)
      - [获取数组中的所有元素](#获取数组中的所有元素)
      - [获取数组长度](#获取数组长度)
    - [传递参数](#传递参数)
    - [基本运算符](#基本运算符)
      - [算术运算符](#算术运算符)
      - [关系运算符](#关系运算符)
      - [布尔运算符](#布尔运算符)
      - [逻辑运算符](#逻辑运算符)
      - [字符串运算符](#字符串运算符)
      - [文件测试运算符](#文件测试运算符)
      - [自增/自减运算符](#自增自减运算符)
        - [使用let命令](#使用let命令)
        - [使用$(())](#使用)
        - [使用expr](#使用expr)
        - [使用(())](#使用-1)
    - [echo命令](#echo命令)
    - [printf命令](#printf命令)
      - [概念](#概念)
      - [常用字符速查](#常用字符速查)
    - [流程控制](#流程控制)
      - [if](#if)
      - [for循环](#for循环)
      - [while语句](#while语句)
      - [until循环](#until循环)
      - [case...esac](#caseesac)
    - [函数](#函数)

## Linux命令

## Shell命令

### Shell变量

#### 变量声明

命名和正常编程语言没有什么区别,不能使用数字开头,不能使用该语言的关键字

特别:不能使用$符号,无需关键字,声明的时候等号两边最好不要空格,会出现问题

```
EG.
普通变量:
Tag="B"
约定:常量使用全大写字母声明
PI="3.14"
```

#### 变量使用

使用美元符号放在前面表示使用

```
PI="3.14"
echo $PI
可以使用花括号帮助系统识别变量边界
echo ${PI}
```

#### 只读变量

先声明一个变量:PI="3.14"
设置成只读变量:readonly PI
只读变量无法修改


#### 删除变量

使用unset可以删除变量:unset PI  
**无法删除只读变量**


#### 数据类型

##### 字符串
shell中的默认类型,也是使用最多的类型

可以使用单引号或者双引号进行声明

单引号的字符都会原样输出,无法在单引号字符串中使用变量,单引号字符串中无法出现单个单引号,即便是转义也不行  

##### 数字

声明:`declare -i`

##### 数组

声明1:`TEST_ARRAY=(value1 value2 value3)`

声明2:单个声明
TEST[0]=value1
TEST[1]=value2

声明关联数组(感觉是个map,key->value)  
`declare -A site=(["google"]="www.google.com" ["runoob"]="www.runoob.com" ["taobao"]="www.taobao.com")`  
这个关联数组也可以像上面一样,先声明之后再给每一个元素单独赋值


访问方式:`${TEST_ARRAY[0]}`

### 注释

`#`号之后的内容不会被执行
```
#这里就会被忽略
```

### 字符串操作

#### 获取字符串长度

```
my_string="abcde"
echo ${#string}  #输出5
```

#### 提取子字符串/切割字符串

```
#定义一个字符串
my_string="hello"
#获取第二到第四个字符
echo ${my_string:1:4}
```


#### 查找字符

```
my_string="hello_world"
echo `expr index ${my_string} ow`
#查找字符o或者w的位置,谁先找到就返回谁的下标
```

### 数组操作

#### 获取数组中的所有元素

使用`@`或者`*`可以获取数组中的所有元素
```
my_arr=("A" "B" "C")
echo ${my_arr[@]}

#输出3
```

在数组前加上一个`!`可以获取所有的index/key
```
my_arr=("A" "B" "C")
echo ${!my_arr[@]}

#输出0 1 2,如果是关联数组,则输出对应的key
```

#### 获取数组长度
```
my_arr=("A" "B" "C")
echo ${#my_arr[@]} #如果不加上@就等价于获取第一个元素的长度
```

### 传递参数

脚本内获取参数的格式为`$n`,n代表一个数字,1表示执行的第一个参数,2表示执行脚本的第二个参数

特殊参数
|参数处理|说明|
|-------|----|
|$0|执行的文件名(包含文件路径)|
|$#|传递到脚本的参数个数|
|$*|将输入的参数以一个字符串输出|
|$$|脚本运行的进程的进程号|
|$!|后台运行的最后一个进程的进程号|
|$@|直接输出所有的参数|
|$-|显示shell使用的当前选项|
|$?|显示最后命令的退出状态|

### 基本运算符

#### 算术运算符

原生bash不支持简单的数学运算,必须通过其他的命令来实现

最常用的是expr命令,可以计算一个表达式的值,表达式必须使用 **`**来包裹

例如:
```
val=`expr 2 + 2`
echo "两数之和为:${val}"
```

**表达式与运算符之间需要空格,就像是css中的calc计算函数一样**

运算符号和一般的编程语言没什么区别:
`+ - * / % =(赋值) == !=`  
**\*号之前需要加上\\来转义不然无法使用,`expr $a \* $b`**

如果作为流程判断语句中的表达式使用时,放入[]中时两边也需要空格,例如`[$a + $b]`是错误的  
必须写成`[ $a + $b ]`

#### 关系运算符

关系运算符是只支持数字,并不支持字符串,除非字符串的值是数字

|运算符|说明|
|------|----|
|-eq|判断是否相等|
|-ne|判断是否不相等|
|-gt| >|
|-lt|<|
|-ge|>=|
|-le|<=|

```
e/eq:equal
n:not
g:greater
l:less
t:than
```

#### 布尔运算符

|运算符|说明|
|------|----|
|!|非运算,取反|
|-o|\|\||
|-a|&&|


#### 逻辑运算符

|运算符|说明|
|------|----|
|&&|逻辑AND|
|\|\||逻辑OR|

**布尔运算符和逻辑运算符的区别**
```
简单来说:
布尔运算符用来连接条件测试
逻辑运算符用来连接命令

判断依据:
布尔运算符:条件表达式的真假结果
逻辑运算符:基于命令的退出状态码,只有执行正确的命令才返回0,shell中0用来表示true
```

**最佳实践**
```
现代基本都是用[[]]结构进行条件判断,这样可以使用&&来连接条件判断,防止-a命令带来的干扰

在[[]]中使用==来进行字符串判等,使用-eq来进行数值判等

$(())或者(())使用==来进行数值判等

$(())会返回一个字符串,作为值存在,(())只是单纯执行了这个命令
```

#### 字符串运算符

|运算符|说明|
|------|----|
|=|判断相等|
|!=|判断不相等|
|-z|判断字符串的长度是否为0|
|-n|判断字符串长度是否不为0|

**这些符号都使用在表达式前  eg: -n$a**

#### 文件测试运算符

太多了,挑了几个感觉会常用的
|运算符|说明|
|------|----|
|-w/-x/-r|判断是否可写/可执行/可读|
|-s|判断文件是否为空,不为空返回true|
|-e|判断目录/文件是否存在|
|-d|判断文件是否是目录|
|-f|判断文件是否是普通文件,既不是目录也不是设备文件|

#### 自增/自减运算符

##### 使用let命令
```
num=1

let num++

let num--
```

##### 使用$(())
```
num=1

num=$((num + 1))

num=$((num - 1))
```

##### 使用expr
```
num=1

num=$(expr $num + 1)

num=$(expr $num - 1)
```

##### 使用(())
```
num=1

((num++))

((num--))
```

**最佳实践:(()),目前最常用的,性能最好,语法简洁**


### echo命令

|关键点|说明|
|-----|----|
|基本语法|echo [选项] [字符串]|
|常用选项|-n输出不换行 -e启动解析字符串中的转义符|
|变量输出|使用$变量名,最好使用双引号|
|彩色输出|使用ANSI转移码\033[XXm|
|输出重定向|>覆盖文件,>>追加到文件的末尾|
|多行输出|使用\n换行|
|可移植建议|复杂的echo建议直接使用printf|

### printf命令

#### 概念

|概念|说明|示例|
|----|----|---|
|基础语法|printf "format" args|printf "这是%s" "pen"|
|格式说明符|以%开头,和c基本一致|%d/%f|
|转义字符|特殊字符表示|\n,\t|
|字段宽度|控制输出最小宽度|%10s(十个字符宽)|
|精度控制|浮点数小数位数|%.2f(两位小数)|

#### 常用字符速查
|说明符|用途|
|---|----|
|%s|字符串|
|%d|十进制整数|
|%x|十六进制整数|
|%f|浮点数|
|%.2f|2位小数|
|%c|单个字符|
|%%|百分号|

### 流程控制

#### if

**else块中没有语句就不能书写**

**if 块**
```
if condition;
then 
  command1
  command2
fi
```

**if else块**
```
if condition;
then
  command1
  ...
else
  command
  ...
fi
```

**if elseif else块**
```
if condition;
then
  command1
  ...
elif condition2;
then
  command
  ...
else
  command
  ...
fi
```

#### for循环

```
for item in item1 item2 item3...
do
  command
  ...
done
```

#### while语句
```
while condition
do
  command
  ...
done
```

死循环:
```
while :
do
  command
  ...
done

while true
do
  command
done

for((;;))
```

#### until循环
```
until condition
do
  command
done
```

#### case...esac

类似switch...case

```
case 值 in
mode1)
  command
  ...
  ;;
mode2)
  command
  ...
  ;;
  *) #相当于default
  command
  ;;
esac
```

**跳出循环也是传统的break跳出循环,continue跳出当前循环**

### 函数

```
[ function ] funcName ()
{
  action
  [return int;]
}

[]中为可选

demoFun(){
  echo "这是我的第一个shell函数"

  echo "这是我的第一个参数$1"
}

echo "---函数开始执行---"
demoFun "helloworld"
echo "---函数执行完毕---"
```

使用$?去获取函数返回值
**$?仅对上一条指令负责,所以获得返回值之后,有需要必须马上使用参数保存**
想要为函数传递参数,就和为脚本传递参数一样,$1,$2之类的